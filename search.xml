<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2020/07/01/vue-think/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 响应式原理篇（一）</span><br><span class="line">date: 2020-07-01</span><br><span class="line">tags: [vue] [souce-code]</span><br><span class="line">categories: 响应式框架</span><br></pre></td></tr></table></figure><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>响应式原理是 vue 的核心，使用 <strong>数据劫持</strong> 实现数据驱动视图。<br>在面试中是经常考查的知识点，也是面试的加分项。</p><p>我们将循序渐进地解析 响应式原理 的工作流程，主要以下面的结构进行：</p><ol><li>分析主要的成员，了解它们有助于理解流程</li><li>将流程进行拆分，理解其中每一段流程的作用</li><li>结合以上的点，来理解整体的流程</li></ol><p>抽象的内容会稍多，会结合代码来进行说明。为了理解核心的原理，我们的代码会进行简化，可以参考源码进行学习</p><h3 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h3><p>在响应式原理中， <code>Observe</code> <code>Dep</code> <code>Watcher</code> 这三个类是构成完整原理的主要成员。</p><ul><li><code>Observe</code> 观测器，响应式原理的入口，根据数据类型处理观测逻辑</li><li><code>Dep</code> 依赖收集器，属性都会有一个 <code>Dep</code>, 方便发生变化的时候能够找到对应的依赖触发更新</li><li><code>Watcher</code> 订阅者，用于执行更新渲染，组件中会拥有一个渲染 <code>Watcher</code> ，我们常说的收集依赖，就是收集 <code>Watcher</code></li></ul><blockquote><p>很像三个小人，它们是一个响应式 Team 的，分工明确，但又互相合作<br>下面来看看这些类的实现，包含哪些主要的属性和方法。</p></blockquote><h4 id="Observe-我会对数据进行观测"><a href="#Observe-我会对数据进行观测" class="headerlink" title="Observe: 我会对数据进行观测"></a>Observe: 我会对数据进行观测</h4><blockquote><p>提示：代码里的序号对应代码块下面的讲解</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置：/src/core/observe/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    def(data, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      protoAugment(data, arrayMethods)</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">this</span>.walk(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  observeArray(data) &#123;</span><br><span class="line">    data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      observe(item)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为观测的属性添加 <code>__ob__</code> 属性，它的值等于 <code>this</code>, 即当前的 <code>Observe</code> 的实例</li><li>为数组添加重写的数组方法，比如： <code>push</code> <code>unshift</code> <code>pop</code> <code>unshift</code> <code>splice</code> 等方法，重写的目的：在调用这些改变原数据的方法时，进行更新渲染</li><li>观测数组内的数据， <code>observe</code> 内部会调用 <code>new Observe</code>, 形成递归的观测</li><li>观测对象数据，<code>defineReactive</code> 为数据定义 <code>get</code> 和 <code>set</code> , 即数据劫持</li></ol><h4 id="Dep-我会为数据收集依赖"><a href="#Dep-我会为数据收集依赖" class="headerlink" title="Dep: 我会为数据收集依赖"></a>Dep: 我会为数据收集依赖</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码的位置： /src/core/observe/dep.js</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = ++id <span class="comment">// dep 的唯一标识</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 储存 Watcher</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  addSub(watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> watcher.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">  Dep.target = watcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Dep</span><br></pre></td></tr></table></figure><ol><li>数据收集依赖的主要方法， <code>Dep.target</code> 是一个 <code>watcher</code> 的实例</li><li>添加 <code>watcher</code> 到数组中，也就是添加依赖</li><li>属性在变化的时会调用 <code>notify</code> 方法，通知每一个依赖进行更新</li><li><code>Dep.target</code> 用来记录 <code>watcher</code> 实例，是全局唯一的，没有从属性质，主要作用是为了在收集依赖的过程中找到对应的 <code>watcher</code> </li></ol><p><code>pushTarget</code> 和 <code>popTarget</code> 这两个方法，显而易见是用来设置 <code>Dep.target</code> 的，这是一个关键点，这个概念初步有些难以理解，但是后面的流程中，会详细讲解它的作用，需要留心这部分内容。</p><h4 id="Watcher-我会触发视图更新"><a href="#Watcher-我会触发视图更新" class="headerlink" title="Watcher: 我会触发视图更新"></a>Watcher: 我会触发视图更新</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置： /src/core/observer/watcher.js</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, exprOrFn, cb, options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = ++id <span class="comment">// watcher 的唯一标识</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">this</span>.getter = exprOrFn</span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get() &#123;</span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.getter()</span><br><span class="line">    popTarget(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="comment">// 为了防止重复添加 dep</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(dep.id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.depIds.add(dep.id)</span><br><span class="line">      <span class="keyword">this</span>.deps.push(dep)</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>this.getter</code> 储存的是更新视图的函数</li><li><code>watcher</code> 储存 <code>dep</code>, 同时 <code>dep</code> 也存储 <code>watcher</code>, 进行双向记录</li><li>触发更新， <code>queueWatcher</code> 是为了进行异步更新，异步更新会调用 <code>run</code> 方法进行更新页面</li></ol><h3 id="响应式原理流程"><a href="#响应式原理流程" class="headerlink" title="响应式原理流程"></a>响应式原理流程</h3><p>对于以上这些成员具有的功能，我们都有了大概的了解。下面结合它们，来看看这些功能是如何在响应式原理流程中工作的。</p><h4 id="1-0-数据观测"><a href="#1-0-数据观测" class="headerlink" title="1.0 数据观测"></a>1.0 数据观测</h4><p>数据在初始化时，会通过 <code>observe</code> 方法来调用 <code>Observe</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码位置： /src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(data)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (data.hasOwnProperty(<span class="string">'__ob__'</span>) &amp;&amp; data.__ob__ <span class="keyword">instanceof</span> Observe) &#123;</span><br><span class="line">    ob = data.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observe(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化时， <code>observe</code> 函数拿到的 <code>data</code> 就是我们在 <code>data</code> 函数内返回的对象</p><ol><li><code>observe</code> 函数只对 <code>object</code> 类型的数据进行观测</li><li>观测过的数据都会被添加上 <code>__ob__</code> 属性，通过判断该属性是否存在，防止重复观测</li><li>创建 <code>Observe</code> 实例，开始处理观测逻辑</li></ol><h4 id="1-1-对象观测"><a href="#1-1-对象观测" class="headerlink" title="1.1 对象观测"></a>1.1 对象观测</h4><p>进入 <code>Observe</code> 内部，由于初始化的数据是一个对象，所以会调用 <code>walk</code> 方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">walk(data) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(data, key, data[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>defineReactive</code> 方法内部使用 <code>Object.defineProperty</code> 对数据进行劫持，是实现响应式数据原理最核心的地方</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(value)</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      value = newVal</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      dep.notify()</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>由于劫持的对象类型可能是嵌套结构，这里需要调用 <code>observe</code> 进行递归观测</li><li>这里的 <code>dep</code> 就是上面讲到的每一个属性都会有一个 <code>dep</code>, 它是作为一个闭包的存在，负责收集依赖和通知更新</li><li>在初始化时，<code>Dep.target</code> 是组件的渲染 <code>watcher</code>, 这里 <code>dep.depend</code> 收集的依赖就是这个 <code>watcher</code> ，<code>childOb.dep.depend</code> 主要就是为数组收集依赖</li><li>设置的新值可能是对象类型，需要对新值再进行观测</li><li>值发生改变， <code>dep.notify</code> 通知 <code>watcher</code> 更新， 这是我们改变数据后能够实时更新页面的触发点</li></ol><p>通过上面的逻辑，也能知道为什么 <code>Vue3.0</code> 要用 <code>Proxy</code> 代替 <code>Object.defineProperty</code> 了。 <code>Object.defineProperty</code> 只能对单个属性进行定义，如果属性是对象类型，需要递归去观测，会消耗性能。而 <code>Proxy</code> 是代理整个对象，只要属性发生了变化就会触发回调。</p><h4 id="1-2-数组观测"><a href="#1-2-数组观测" class="headerlink" title="1.2 数组观测"></a>1.2 数组观测</h4><p>对于数组类型观测，会调用 <code>observerArray</code> 方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">observeArray(data) &#123;</span><br><span class="line">  data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    observe(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与对象不同，它执行 <code>observe</code> 对数组内的对象类型进行观测，并没有对数组的每一项进行 <code>Object.defineProperty</code> 的定义， 也就是说数组内的项是没有 <code>dep</code> 的。</p><p>所以，我们通过数组的索引对项进行修改时，是不会触发更新的，但可以通过 <code>this.$set</code> 来修改触发更新。那么问题来了，为什么 <code>Vue</code> 要这样设计？</p><p>结合实际使用的场景，数组中通常会存放很多数据，比如：列表数据。这样观测起来会很消耗性能。还有一点原因，一般数组修改元素很少直接通过索引将整个元素替换掉。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123; id: 1, name: &apos;Jack&apos; &#125;,</span><br><span class="line">        &#123; id: 2, name: &apos;Mike&apos; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    // 如果想要修改 name 的值，一般是这样使用</span><br><span class="line">    this.list[0].name = &apos;JOJO&apos;</span><br><span class="line">    // 而不是以下这样</span><br><span class="line">    this.list[0] = &#123; id: 1, name: &apos;JOJO&apos; &#125;</span><br><span class="line">    // 当然可以这样更新</span><br><span class="line">    this.$set(this.list, &apos;0&apos;, &#123; id: 1, name: &apos;JOJO&apos; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-3-数组方法重写"><a href="#1-3-数组方法重写" class="headerlink" title="1.3 数组方法重写"></a>1.3 数组方法重写</h4><p>当数组元素新增或删除，视图都会随之更新。这并不是理所当然的，而是 <code>Vue</code> 内部重写了数组的方法，调用这些方法时，数组会更新检测，触发视图更新。这些方法包括：</p><ul><li>push()</li><li>pop()</li><li>unshift()</li><li>shift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>回到 <code>Observe</code> 类中，当观测的数据类型是数组时，会调用 <code>protoAugment</code> 方法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">  protoAugment(data, arrayMethods)</span><br><span class="line">  <span class="comment">// 观测数组</span></span><br><span class="line">  <span class="keyword">this</span>.observeArray(data)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 观测对象</span></span><br><span class="line">  <span class="keyword">this</span>.walk(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面把数组原型替换为 <code>arrayMethods</code> ，当调用改变数组的方法时，优先使用重写后的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">data, arrayMethods</span>) </span>&#123;</span><br><span class="line">  data.__propt__ = arrayMethods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 <code>arrayMethods</code> 是如何实现的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 源码位置：/src/core/observer/array.js</span><br><span class="line">//  1</span><br><span class="line">let arrayProto = Array.prototype</span><br><span class="line">// 2</span><br><span class="line">export let arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">let methods = [</span><br><span class="line">  &apos;push&apos;,</span><br><span class="line">  &apos;pop&apos;,</span><br><span class="line">  &apos;shift&apos;,</span><br><span class="line">  &apos;unshift&apos;,</span><br><span class="line">  &apos;reverse&apos;,</span><br><span class="line">  &apos;sort&apos;,</span><br><span class="line">  &apos;splice&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">methods.forEach(method =&gt; &#123;</span><br><span class="line">  arrayMethods[method] = function(...args) &#123;</span><br><span class="line">    // 3</span><br><span class="line">    let res = arrayProto[method].apply(this, args)</span><br><span class="line">    let ob = this.__ob__</span><br><span class="line">    let inserted = &apos;&apos;</span><br><span class="line">    switch(method) &#123;</span><br><span class="line">      case &apos;push&apos;:</span><br><span class="line">      case &apos;unshift&apos;: </span><br><span class="line">        inserted = args</span><br><span class="line">        break;</span><br><span class="line">      case &apos;splice&apos;:</span><br><span class="line">        inserted = args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    // 4</span><br><span class="line">    inserted &amp;&amp; ob.observeArray(inserted)</span><br><span class="line"></span><br><span class="line">    // 5</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>webpack构建（一）</title>
      <link href="/2020/06/23/engineering/webpack%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <content type="html"><![CDATA[<h2 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a>什么是 webpack</h2><p>用一张图来形象地进行解释：</p><p><img src="https://img2020.cnblogs.com/blog/1598468/202006/1598468-20200620223156642-1303010106.png" alt=""></p><p>它是一个 <strong>静态的模块打包器</strong>， 从 <code>entry</code> 入口出发，递归地寻找模块间的依赖关系，比如：图片、css、js… 最后把这些模块资源进行整合成一个或多个 bundle</p><h2 id="webpack-的入口"><a href="#webpack-的入口" class="headerlink" title="webpack 的入口"></a>webpack 的入口</h2><p>webpack中的 entry 是进行寻找依赖关系的起点，所有和它直接或者间接相关的依赖，都会直接被处理，随后进入到 bundle 中<br>支持两种配置方式：</p><ul><li>单入口<br>entry 是一个字符串</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/main.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多入口<br>entry 是一个对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="webpack-的出口"><a href="#webpack-的出口" class="headerlink" title="webpack 的出口"></a>webpack 的出口</h2><p>指定输出 bundle 的位置</p><ul><li><p>单入口场景</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多入口场景<br>文件名的指定使用 <strong>占位符</strong> 的方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/index.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;[name].js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="webpack-中的-loader"><a href="#webpack-中的-loader" class="headerlink" title="webpack 中的 loader"></a>webpack 中的 loader</h2><p>webpack 开箱即用只支持 <code>js</code> <code>json</code> 两种文件类型，对于向 <code>vue</code> <code>jsx</code> 等其他文件类型，需要通过 <code>loader</code> 进行有效的转化，并添加到依赖树中。</p><p>本身是一个函数，接受源文件作为参数，返回值是转化后的结果。</p><p>常用 loader:</p><ul><li>babel-loader </li><li>css-loader</li><li>less-loader</li><li>ts-loader</li><li>file-loader 图片、字体富媒体文件</li><li>raw-loader 把文件用字符串形式进行导入</li><li>thread-loader 多进程打包，提升效率</li></ul><p>使用方法：<br>在 module 中的 rules 数组中进行配置， <code>test</code> 属性指定匹配的规则， <code>use</code> 属性指定使用的 loader 名称<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        text: /\.txt$/,</span><br><span class="line">        use: &apos;raw-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="webpack中的插件-plugins"><a href="#webpack中的插件-plugins" class="headerlink" title="webpack中的插件 plugins"></a>webpack中的插件 plugins</h2><p><code>plugins</code> 可以理解为 <code>loader</code> 的一个强化，任何 <code>loader</code> 不能进行处理的事情都可以交给 <code>plugin</code> 进行解决<br>通常用于 bundle 文件的优化、资源管理和环境变量注入， <strong>它作用于整个打包构建过程的</strong></p><p>比如： 打包之前需要手动删除 <code>dist</code> 文件</p><p>常用的 plugins:</p><ul><li>CommonsChunkPlugin 把相同的 chunk 打包成一个公共的js</li><li>CleanWebpackPlugin 清理构建目录</li><li>ExtractTextWebpackPlugin 将 css 从 bundle 文件中提取成一个独立的 css 文件</li><li>CopyWebpackPlugin 把文件或文件夹复制到打包后的输出目录</li><li>HtmlWebpackPlugin 创建 html 文件去引入输出的 bundle</li><li>UglifyjsWebpackPlugin 压缩js</li><li>ZipWebpackPlugin 打包后的资源生成一个压缩的 zip 包</li></ul><p>plugin 的使用<br>先引入插件包， 然后添加到 <code>plugins</code> 数组中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.txt$/,</span><br><span class="line">        use: &apos;raw-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos; &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="webpack-中的模式-mode"><a href="#webpack-中的模式-mode" class="headerlink" title="webpack 中的模式 mode"></a>webpack 中的模式 mode</h2><p>mode 用来指定当前的构建环境是 <code>production</code> 、<code>development</code> 、<code>node</code> 设置 mode 可以使用 webpack 内置的函数，默认值是 <code>production</code></p><p>内置函数功能</p><ul><li>development 设置 <code>process.env.NODE_ENV</code> 的值为 <code>development</code>, 开启 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code> 主要是在热更新阶段，可以在控制台打印出哪个模块发生了变化</li><li>production 设置 <code>process.env.NODE_ENV</code> 的值为 <code>production</code>, 开启 <code>FlagDependencyUsagePlugin</code> 、<code>FlagIncludedChunksPlugin</code> … 主要会给js进行压缩，判断代码的副作用等等</li><li>none 不开启任何优化</li></ul><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;development&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="资源解析"><a href="#资源解析" class="headerlink" title="资源解析"></a>资源解析</h2><h3 id="es6-文件处理"><a href="#es6-文件处理" class="headerlink" title="es6 文件处理"></a>es6 文件处理</h3><p>使用 <code>babel-loader</code> 来进行转化， 而 <code>babel-loader</code> 又依赖 <code>babel</code> ， 所以我们还要引入 <code>babel</code> ，它的配置文件是 <code>.babelrc</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/core @babel/preset-env babel-loader</span><br></pre></td></tr></table></figure></p><p>babel 的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@babel/preset-env&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;@babel/proposal-class-properties&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="react-文件处理"><a href="#react-文件处理" class="headerlink" title="react 文件处理"></a>react 文件处理</h3><p>在 presets 中添加 <code>@babel/preset-react</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i  react react-dom</span><br><span class="line">npm i @babel/preset-react -D</span><br></pre></td></tr></table></figure></p><p>修改 presets 配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;presets&quot;: [</span><br><span class="line">    &quot;@babel/preset-env&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>写react相关的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const React from &apos;react&apos;</span><br><span class="line">const ReactDom from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;Hi&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;App/&gt;,</span><br><span class="line">  document.querySelector(&apos;#root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="less-、css-文件的处理"><a href="#less-、css-文件的处理" class="headerlink" title="less 、css 文件的处理"></a>less 、css 文件的处理</h3><p>使用 <code>css-loader</code> 加载 <code>.css</code> 文件，并转成 commonjs 对象； <code>style-loader</code> 将样式通过 <code>&lt;style&gt;</code> 标签插入到 head 中<br>使用 <code>less less-loader</code> 处理 <code>.less</code> 文件</p><p>使用方法：<br>loader 的调用是链式的，从右向左进行调用; css 文件需要在模块中手动引入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;,</span><br><span class="line">          &apos;css-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.less$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;less-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="图片、字体-文件的处理"><a href="#图片、字体-文件的处理" class="headerlink" title="图片、字体 文件的处理"></a>图片、字体 文件的处理</h3><p>使用 <code>file-loader</code> 处理文件和字体， 使用 <code>url-loader</code> 也可以处理，小图片可以设置 base64</p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|gif|svg|jpeg)$/,</span><br><span class="line">        use: &apos;file-loader&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(ttf|woff|woff2|eot|otf)$/,</span><br><span class="line">        use: &apos;file-loader&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>url-loader</code> 使用方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|gif|svg|jpeg)$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &apos;url-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: 10240</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="文件的监听"><a href="#文件的监听" class="headerlink" title="文件的监听"></a>文件的监听</h3><p>当文件发生变化的时候，自动打包构建<br>开启监听的方式：</p><ul><li>命令行启动时，加上 <code>--watch</code> 参数</li><li>在配置 webpack.config.js 中设置 <code>watch: true</code></li></ul><p>文件监听的原理：<br>webpack 通过轮询的方式判断文件最后编辑的时间是否变化，某个文件的编辑时间发生了变化并不会立即告诉监听者，而是等待 <code>aggregateTimeout</code> 过后进行打包刷新</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  watch: true,</span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    // 忽略监听的文件，默认是空</span><br><span class="line">    ignored: /node_modules/,</span><br><span class="line">    // 监听到文件变化后的 300ms 再去执行，默认是 300ms</span><br><span class="line">    aggregateTimeout: 300,</span><br><span class="line">    // 轮询文件的周期，默认每秒询问 1000 次</span><br><span class="line">    poll: 1000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack-中的热更新"><a href="#webpack-中的热更新" class="headerlink" title="webpack 中的热更新"></a>webpack 中的热更新</h3><p>使用 <code>webpack-dev-server</code> 进行监听，不会频繁刷新浏览器，它不是直接输出文件，而是寄放在内存中, 没有磁盘的 I/O 操作<br>使用了 <code>HotModuleReplacementPlugin</code> 插件</p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &apos;./dist&apos;,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;wepack-dev-server --open&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>日常开发中 <code>webpack-dev-middleware</code> 也可以实现热更新，通常用于制定更灵活的方案</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    hello: [&apos;webpack-hot-middleware/client?noInfo=true&amp;reload=true&apos;, &apos;./src/index.js&apos;],</span><br><span class="line">    world: [&apos;webpack-hot-middleware/client?noInfo=true&amp;reload=true&apos;, &apos;./src/world.js&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// server.js</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">const webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;)</span><br><span class="line">const hotMiddleWare = require(&apos;webpack-hot-middleware&apos;)</span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line">const config = require(&apos;./webpack.config.js&apos;)</span><br><span class="line">const compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: config.output.publicPath</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(hotMiddleWare(compiler, &#123;</span><br><span class="line">   log: false,</span><br><span class="line">   heartbeat: 2000</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(3000, function() &#123;</span><br><span class="line">  console.log(&apos;dev server running port: 3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="webpack-中热更新的原理"><a href="#webpack-中热更新的原理" class="headerlink" title="webpack 中热更新的原理"></a>webpack 中热更新的原理</h3><p>先来了解几个概念：</p><ul><li>webpack compiler 把 js 编译成 bundle</li><li>HMR Server 把热更新后的文件通过 websocket | sse 输出给 HMR Runtime (被提前放在 bundle 中)</li><li>Bundle Server 提供浏览器端 bundle 的访问</li><li>HMR Runtime 会注入到浏览器，跟 HMR Server 进行交互</li><li>bundle.js 更新后的输出的文件</li></ul><p>分为两个阶段：<br>启动阶段： 文件系统进行编译，经过 wk 进行编译打包，打包之后会交由 <code>Bundle Server</code> 进行分发， 并在分发的 <code>bundle.js</code> 中注入 <code>HMR Runtime</code><br>文件的更新阶段： 文件系统变化被 wk 监听编译，然后发送给 <code>HMR Server</code> 哪些文件变化，告诉给 <code>HMR Runtime</code>, 通常是以一个 json 文件形式进行传输，<br>再由 <code>HMR Runtime</code> 进行改变</p><h3 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h3><p>常用的类型有三种：</p><ul><li>hash 和整个项目的构建相关，是工程级别的，只要项目文件有更改整个 hash 值就会更改</li><li>chunkhash 和打包后的 chunk 有关，具体是根据不同的 <code>entry</code> 配置来分析依赖项并生成 <code>chunk</code>, 生成 <code>chunkhash</code></li><li>contenthash 文件内容发生变化，<code>contenthash</code> 才会改变<br>三种 <code>hash</code> 主要是用来解决线上资源的 <code>文件缓存策略</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const miniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;./dist&apos;),</span><br><span class="line">    filename: &apos;[name][chunkhash:8].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new miniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][contenthash:8].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|svg|jpg|jpeg|gif)$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &apos;file-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: &apos;[name][hash:8].[ext]&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.less$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;less-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备注：webpack警告打包文件过大，建议分片</strong><br>WARNING in webpack performance recommendations:<br>You can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.<br>For more info visit <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">https://webpack.js.org/guides/code-splitting/</a></p><h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><p>webpack4 内置了 <code>uglifyjs-webpack-plugin</code> , 可以手动下载控制并行压缩<br>使用 <code>optimize-css-assets-webpack-plugin cssnano</code> 对css进行压缩<br>使用 <code>html-webpack-plugin</code> 进行文件压缩 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123; </span><br><span class="line">      template: &apos;./src/index.html&apos;,</span><br><span class="line">      filename: &apos;index_1.html&apos;,</span><br><span class="line">      chunks: [&apos;hello&apos;, &apos;world&apos;],</span><br><span class="line">      inject: true,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        html5: true,</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        preserveLineBreaks: false,</span><br><span class="line">        minifyCSS: true,</span><br><span class="line">        minifyJS: true,</span><br><span class="line">        removeComments: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    new optimizeCssAssetsWebpackPlugin(&#123;</span><br><span class="line">      assetNameRegExp: /\.css$/g,</span><br><span class="line">      cssProcessor: require(&apos;cssnano&apos;)</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清理输出目录"><a href="#清理输出目录" class="headerlink" title="清理输出目录"></a>清理输出目录</h3><p>1、在 script 中增加脚本命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ./dist &amp;&amp; webpack</span><br></pre></td></tr></table></figure></p><p>2、使用 <code>CleanWebpackPlugin</code> 插件, 默认删除 output 指定的目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">plugins: [</span><br><span class="line">  new CleanWebpackPlugin()</span><br><span class="line">]</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></p><h3 id="css-兼容性问题"><a href="#css-兼容性问题" class="headerlink" title="css 兼容性问题"></a>css 兼容性问题</h3><p>使用 <code>autoprefixer</code> 插件，是 css 的后置处理器，代码生成完成后进行处理<br>根据 <code>caniuse</code> 网站进行前缀优化， 通常和 <code>postcss-loader</code> 配置使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    plugins: () =&gt; [</span><br><span class="line">      require(&apos;autoprefixer&apos;)(&#123;</span><br><span class="line">        browsers: [&apos;last 2 version&apos;, &apos;&gt;1%&apos;, &apos;ios 7&apos;]</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h3 id="css中-rem-转换"><a href="#css中-rem-转换" class="headerlink" title="css中 rem 转换"></a>css中 rem 转换</h3><p>关于像素和手机屏幕密度等的问题，我还没彻底从工艺设备的角度理解，但是用 “田” 字模型去理解我们开发中的 retina 屏以及其他的3倍屏…<br>其实从编程的角度而言，已然够用。 <img src="https://github.com/jawil/blog/issues/21" alt="参考资料"></p><p>手机分辨率进行适配的方式：</p><ul><li>css 媒体查询</li><li>rem 全局的相对单位 <code>font-size of the root element</code>， 而 <code>px</code> 是一个固定单位值，在不同分辨率的手机上是一样的<br>使用 <code>px2rem-loader</code> 转换 <code>rem</code> 为 <code>px</code></li><li><code>viewport</code> 方案</li></ul><p>页面渲染时，要根据手机分辨率计算根元素的 <code>font-size</code> 的值，</p><ul><li>利用手淘方案 <code>lib-flexible</code> <img src="https://github.com/amfe/lib-flexible" alt="lib-flexible"></li><li>结合使用场景编写，比如为了计算方便可以设置 750px 对应的 1rem = 100px； 同时 750/100 = clientWidth/htmlFontSize</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 以下这段代码是用于根据移动端设备的屏幕分辨率计算出合适的根元素的大小</span><br><span class="line">  * 当设备宽度为375(iPhone6)时，根元素font-size=16px; 依次增大；</span><br><span class="line">  * 限制当为设备宽度大于768(iPad)之后，font-size不再继续增大</span><br><span class="line">  * scale 为meta viewport中的缩放大小</span><br><span class="line">  */</span><br><span class="line">(function (doc, win) &#123;</span><br><span class="line">  var docEl = win.document.documentElement;</span><br><span class="line">  var resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;;</span><br><span class="line">  var dpr = window.devicePixelRatio || 1;</span><br><span class="line">  var metaEl = doc.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);</span><br><span class="line">  var scale = 1 / dpr;</span><br><span class="line">  /**</span><br><span class="line">  * ================================================</span><br><span class="line">  *   设置data-dpr和viewport</span><br><span class="line">  *   1px线条的显示问题解决：1px的CSS像素，占用的物理也是1</span><br><span class="line">  × ================================================</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  docEl.setAttribute(&apos;data-dpr&apos;, dpr);</span><br><span class="line">  // 动态改写meta:viewport标签</span><br><span class="line">  &lt;!-- if (!metaEl) &#123;</span><br><span class="line">    metaEl = doc.createElement(&apos;meta&apos;);</span><br><span class="line">    metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</span><br><span class="line">    metaEl.setAttribute(&apos;content&apos;, &apos;width=device-width, initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</span><br><span class="line">    document.documentElement.firstElementChild.appendChild(metaEl);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    metaEl.setAttribute(&apos;content&apos;, &apos;width=device-width, initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</span><br><span class="line">  &#125; --&gt;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * ================================================</span><br><span class="line">    *   设置根元素font-size</span><br><span class="line">    * 当设备宽度为375(iPhone6)时，根元素font-size=16px; </span><br><span class="line">    × ================================================</span><br><span class="line">    */</span><br><span class="line">  var refreshRem = function () &#123;</span><br><span class="line">    var clientWidth = win.innerWidth</span><br><span class="line">                      || doc.documentElement.clientWidth</span><br><span class="line">                      || doc.body.clientWidth;</span><br><span class="line"></span><br><span class="line">    if (!clientWidth) return;</span><br><span class="line">    var fz;</span><br><span class="line">    var width = clientWidth;</span><br><span class="line">    if (width &gt;= 768) &#123;</span><br><span class="line">      fz = 16 * 768 / 375;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fz = 16 * width / 375;</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.style.fontSize = fz + &apos;px&apos;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // detect 0.5px supports</span><br><span class="line">  if (dpr &gt;= 2) &#123;</span><br><span class="line">    var fakeBody = document.createElement(&apos;body&apos;)</span><br><span class="line">    var testElement = document.createElement(&apos;div&apos;)</span><br><span class="line">    testElement.style.border = &apos;.5px solid transparent&apos;</span><br><span class="line">    fakeBody.appendChild(testElement)</span><br><span class="line">    docEl.appendChild(fakeBody)</span><br><span class="line">    if (testElement.offsetHeight === 1) &#123;</span><br><span class="line">      docEl.classList.add(&apos;hairlines&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!doc.addEventListener) return;</span><br><span class="line">  win.addEventListener(resizeEvt, refreshRem, false);</span><br><span class="line">  doc.addEventListener(&apos;DOMContentLoaded&apos;, refreshRem, false);</span><br><span class="line">  refreshRem();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure><h3 id="资源内联"><a href="#资源内联" class="headerlink" title="资源内联"></a>资源内联</h3><p>把 <code>font css js ...</code> 内联到 html 中<br>优点： </p><ul><li>页面框架的初始化脚本（最先执行）</li><li>css 内联避免页面的样式闪动</li><li>请求层面可以减少 http 网络的请求数</li></ul><p>使用 <code>raw-loader</code> 内联 html  <code>npm i raw-loader@0.5.1 -D</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  &lt;%= require(&apos;raw-loader!babel-loader!./meta.html&apos;) %&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>使用 <code>style-loader</code> 或者 <code>html-inline-css-webpack-plugin</code> 内联css</p><h3 id="tree-shaking（摇树优化）"><a href="#tree-shaking（摇树优化）" class="headerlink" title="tree shaking（摇树优化）"></a>tree shaking（摇树优化）</h3><p>webpack2 开始支持，需要使用 es6 的语法，Nodejs中的 cjs 是不支持的。思想：DCE<br>代码中不会达到，代码的结果不会被用到，或代码只写不读，都会被删除<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (false) &#123;</span><br><span class="line">  console.log(&apos;...&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原理：利用 es6 模块的特点：</p><ul><li>只能作为模块顶层的语句出现</li><li>import 的模块只能是字符串常量</li><li>import binding 是 immutable</li></ul><p>代码擦除： <code>uglify</code> 阶段删除无用的代码, 要注意在某些可能产生“副作用”的代码中，<code>tree-shaking</code> 会失效</p>]]></content>
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
